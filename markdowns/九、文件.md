```c
 if (!EOF){
    printf("Hello, World!\n");
  }

//  const char * 
  char const* a = "hello";
  a[2] = 'b';
  a = "asdasd";
  char * const b = "world";
  b = "aaaa";
  b[2] = 'c';

//  const char * const s;
```





## 文件输入输出

- #### fopen: FILE *fopen(char *filename, char *mode)

  - 
    
    | 打开方式 | 说明 |
    | :------: | :--: |
    |               "r"                | 以“只读”方式打开文件。只允许读取，不允许写入。文件必须存在，否则打开失败。 |
    |               "w"                | 以“写入”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。 |
    |               "a"                | 以“追加”方式打开文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。 |
    |               "r+"               | 以“读写”方式打开文件。既可以读取也可以写入，也就是随意更新文件。文件必须存在，否则打开失败。 |
    |               "w+"               | 以“写入/更新”方式打开文件，相当于`w`和`r+`叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么清空文件内容（相当于删除原文件，再创建一个新文件）。 |
    |               "a+"               | 以“追加/更新”方式打开文件，相当于a和r+叠加的效果。既可以读取也可以写入，也就是随意更新文件。如果文件不存在，那么创建一个新文件；如果文件存在，那么将写入的数据追加到文件的末尾（文件原有的内容保留）。 |
    |             打开方式             | 说明                                                         |
    |               "t"                | 文本文件。如果不写，默认为`"t"`。                            |
    |               "b"                | 二进制文件。                                                 |
    
  - ferror：判断文件是否出错
  
  - feof：判断是否到文件末尾



- #### 错误流

  - errno错误码：整型
  - strerror(errno)错误：错误码对应的字符串
  - perror("MES")错误提示：错误提示信息
  - 在错误流打印的就是perror+strerror



## 文件流的缓冲

- #### **void setbuf(FILE \*stream, char \*buffer)**

  - **stream** -- 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流
  - **buffer** -- 这是分配给用户的缓冲，它的长度至少为 BUFSIZ 字节，BUFSIZ 是一个宏常量，表示数组的长度

- ####  **int setvbuf(FILE \*stream, char \*buffer, int mode, size_t size)**

  - **stream** -- 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流
  - **buffer** -- 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲
  - **mode** -- 这指定了文件缓冲的模式
    - _IOFBF**全缓冲**：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充
    - _IOLBF**行缓冲**：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符
    - _IONBF**无缓冲**：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略
  - **size** --这是缓冲的大小，以字节为单位

- #### 缓冲区变量的作用域应该比文件的更大

  - 全局变量
  - 手动malloc和free

- #### fflush将缓冲流置空



## 读写一个字符

- #### getchar：从stdin读取一个字符

- #### getc, fgetc：从指定的流中读取一个字符

- #### getchar===getc(stdin)

- #### putchar：向控制台写入一个字符

- #### putc,fputc：向指定的流中写入一个字符

  - int fputc(int char, FILE *stream)：如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF，并设置错误标识符

- #### putchar(c)===putc(c,stdout)

- #### EOF：代表一个流的结束，并不是一个文件的结束符！！文件末尾可以返回EOF，发生错误也会返回EOF



## 复制文件-1

- #### 读一个不存在的文件会出错，写一个不存在的文件会自动创建一个文件

- #### 文本文件与二进制文件区别：

  - 能存储的数据类型不同
    文本文件只能存储char型字符变量。二进制文件可以存储char/int/short/long/float/……各种变量值。
  - 每条数据的长度
    文本文件每条数据通常是固定长度的。以ASCII为例，每条数据(每个字符)都是1个字节。进制文件每条数据不固定。如short占两个字节，int占四个字节，float占8个字节……
  - 读取的软件不同
    文本文件编辑器就可以读写。比如记事本、NotePad++、Vim等。二进制文件需要特别的解码器。比如bmp文件需要图像查看器，rmvb需要播放器……
  - 操作系统对换行符(‘\n’)的处理不同（不重要）
    文本文件，操作系统会对’\n’进行一些隐式变换，因此文本文件直接跨平台使用会出问题。
    在Windows下，写入’\n’时，操作系统会隐式的将’\n’转换为”\r\n”，再写入到文件中；读的时候，会把“\r\n”隐式转化为’\n’，再读到变量中。
    在Linux下，写入’\n’时，操作系统不做隐式变换。
    二进制文件，操作系统不会对’\n’进行隐式变换，很多二进制文件（如电影、图片等）可以跨平台使用。



## 读写一行字符

- #### gets_s

  - char*   _Buffer：缓冲
  - rsize_t _Size：读多少

- #### fgets

  - char*   _Buffer：缓冲
  - rsize_t _Size：读多少
  - Stream：什么流

- #### puts,fputs



## 复制文件-2

- #### **char \*setlocale(int category, const char \*locale)** 设置或读取地域化信息

  - category -- 这是一个已命名的常量，指定了受区域设置影响的函数类别。
    - **LC_ALL** 包括下面的所有选项。
    - **LC_COLLATE** 字符串比较。参见 strcoll()。
    - **LC_CTYPE** 字符分类和转换。例如 strtoupper()。
    - **LC_MONETARY** 货币格式，针对 localeconv()。
    - **LC_NUMERIC** 小数点分隔符，针对 localeconv()。
    - **LC_TIME** 日期和时间格式，针对 strftime()。
    - **LC_MESSAGES** 系统响应。
  - **locale** -- 如果 locale 是 NULL 或空字符串 ""，则区域名称将根据环境变量值来设置，其名称与上述的类别名称相同

- #### 频繁的IO读写会降低计算机的性能，应该在缓冲里读入一定量的数据再进行IO操作

​                                                                              
